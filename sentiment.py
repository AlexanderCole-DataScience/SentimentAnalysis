# -*- coding: utf-8 -*-
"""Sentiment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/103N-k_yUvX7cdnMHAGrFroYsZzwqrZL_
"""

import pandas as pd

df = pd.read_excel('/content/LinkedInReviews.xlsx')

print(df)

from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.svm import SVC
from sklearn import metrics
from sklearn.metrics import confusion_matrix


#DataFrame 'df' with columns 'Review' and 'Sentiment'
X_train, X_test, y_train, y_test = train_test_split(df['Review'], df['Sentiment'], test_size=0.5, random_state=42)

vectorizer = TfidfVectorizer(stop_words='english')
X_train_vectorized = vectorizer.fit_transform(X_train)
X_test_vectorized = vectorizer.transform(X_test)

model = SVC(kernel='linear')
model.fit(X_train_vectorized, y_train)

predictions = model.predict(X_test_vectorized)

#Converts 'y' variable to 1's and 0's
y_test = [1 if label == "positive" else 0 for label in y_test]
predictions = [1 if label == "positive" else 0 for label in predictions]

confusion_matr = confusion_matrix(y_test, predictions)

print("Accuracy:", metrics.accuracy_score(y_test, predictions))
print("Precision:", metrics.precision_score(y_test, predictions))
print("Recall:", metrics.recall_score(y_test, predictions))
print("F1 Score:", metrics.f1_score(y_test, predictions))
print(confusion_matr)

from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.svm import SVC
from sklearn.ensemble import RandomForestClassifier
from sklearn import metrics

#DataFrame 'df' with columns 'Review' and 'Sentiment'
X_train, X_test, y_train, y_test = train_test_split(df['Review'], df['Sentiment'], test_size=0.2, random_state=42)

vectorizer = TfidfVectorizer(stop_words='english')
X_train_vectorized = vectorizer.fit_transform(X_train)
X_test_vectorized = vectorizer.transform(X_test)

model = RandomForestClassifier()
model.fit(X_train_vectorized, y_train)

predictions = model.predict(X_test_vectorized)

y_test = [1 if label == "positive" else 0 for label in y_test]
predictions = [1 if label == "positive" else 0 for label in predictions]


print("Accuracy:", metrics.accuracy_score(y_test, predictions))
print("Precision:", metrics.precision_score(y_test, predictions))
print("Recall:", metrics.recall_score(y_test, predictions))
print("F1 Score:", metrics.f1_score(y_test, predictions))

#Decision tree classifier
def decision_tree_classifier(train_x, train_y):
  from sklearn import tree
  model = tree.DecisionTreeClassifier()
  model.fit(train_x, train_y)
  return model

  #KNN Classifier
def knn_classifier(train_x, train_y):
  from sklearn.neighbors import KNeighborsClassifier
  model = KNeighborsClassifier()
  model.fit(train_x,train_y)
  return model

  #Naive Bayes Classifier
def naive_bayes_classifier(train_x, train_y):
  from sklearn.naive_bayes import MultinomialNB
  model = MultinomialNB(alpha = 0.01)
  model.fit(train_x, train_y)
  return model

  #Logistic Regression Classifier
def logistic_regression_classifier(train_x, train_y):
  from sklearn.linear_model import LogisticRegression
  model = LogisticRegression(penalty = 'l2')
  model.fit(train_x, train_y)
  return model

  #Gradient Boosting Classifier
def Gradient_Boosting_Classifier(train_x, train_y):
  from sklearn.ensemble import GradientBoostingClassifier
  model = GradientBoostingClassifier()
  model.fit(train_x, train_y)
  return model

  #SVM Classifier
def svm_classifier(train_x, train_y):
  from sklearn.svm import SVC
  model = SVC(kernel = 'rbf', probability= True)
  model.fit(train_x, train_y)
  return model

  # Random Forest Classifier
def random_forest_classifier(train_x, train_y):
  from sklearn.ensemble import RandomForestClassifier
  model = RandomForestClassifier(n_estimators= 100)
  model.fit(train_x, train_y)
  return model

test_classifiers = [
    'KNN',
    'DT',
    'NB',
    'LR',
    'RF',
    'SVM',
    'GBDT'
]
classifiers = {
    'KNN':knn_classifier,
    'DT':decision_tree_classifier,
    'NB':naive_bayes_classifier,
    'LR':logistic_regression_classifier,
    'RF':random_forest_classifier,
    'SVM':svm_classifier,
    'GBDT':Gradient_Boosting_Classifier

}

for classifier in test_classifiers:
  print('***************** %s *************' % classifier)

  X_train, X_test, y_train, y_test = train_test_split(df['Review'], df['Sentiment'], test_size=0.2, random_state=42)

  vectorizer = TfidfVectorizer(stop_words='english')
  X_train_vectorized = vectorizer.fit_transform(X_train)
  X_test_vectorized = vectorizer.transform(X_test)

  model = RandomForestClassifier()
  model.fit(X_train_vectorized, y_train)

  predictions = model.predict(X_test_vectorized)

  y_test = [1 if label == "positive" else 0 for label in y_test]
  predictions = [1 if label == "positive" else 0 for label in predictions]


  print("Accuracy:", metrics.accuracy_score(y_test, predictions))
  print("Precision:", metrics.precision_score(y_test, predictions))
  print("Recall:", metrics.recall_score(y_test, predictions))
  print("F1 Score:", metrics.f1_score(y_test, predictions))

from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.svm import SVC
from sklearn import metrics
from sklearn.metrics import confusion_matrix


#DataFrame 'df' with columns 'Review' and 'Sentiment'
X_train, X_test, y_train, y_test = train_test_split(df['Review'], df['Sentiment'], test_size=0.4, random_state=42)

vectorizer = TfidfVectorizer(stop_words='english')
X_train_vectorized = vectorizer.fit_transform(X_train)
X_test_vectorized = vectorizer.transform(X_test)

model = SVC(kernel='linear')
model.fit(X_train_vectorized, y_train)

predictions = model.predict(X_test_vectorized)

#Converts 'y' variable to 1's and 0's
y_test = [1 if label == "positive" else 0 for label in y_test]
predictions = [1 if label == "positive" else 0 for label in predictions]



print("Accuracy:", metrics.accuracy_score(y_test, predictions))
print("Precision:", metrics.precision_score(y_test, predictions))
print("Recall:", metrics.recall_score(y_test, predictions))
print("F1 Score:", metrics.f1_score(y_test, predictions))